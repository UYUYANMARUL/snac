{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 2751790718874427450,
  "abi": {
    "parameters": [
      {
        "name": "utxos",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "struct",
            "path": "InUtxo",
            "fields": [
              {
                "name": "deposit_hash",
                "type": {
                  "kind": "array",
                  "length": 32,
                  "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "array",
                  "length": 32,
                  "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                }
              },
              {
                "name": "signature",
                "type": {
                  "kind": "array",
                  "length": 64,
                  "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                }
              },
              {
                "name": "nullifier_hash",
                "type": {
                  "kind": "array",
                  "length": 32,
                  "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "public_key_x",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "public_key_y",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "utxo_commitments",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          }
        },
        "visibility": "public"
      },
      {
        "name": "ownership_commitments",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          }
        },
        "visibility": "public"
      },
      {
        "name": "utxo_len",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "private"
      },
      {
        "name": "contract_address",
        "type": {
          "kind": "array",
          "length": 20,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "send_amount",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "deposit_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "nullifier_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "struct",
        "path": "ReturnValues",
        "fields": [
          {
            "name": "utxo_commitment",
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          },
          {
            "name": "utxo_bytes",
            "type": {
              "kind": "array",
              "length": 116,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          }
        ]
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "19": {
      "source": "use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\n#[deprecated(\"keccak256 is being deprecated from the stdlib, use https://github.com/noir-lang/keccak256 instead\")]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n",
      "path": "std/hash/keccak.nr"
    },
    "20": {
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "61": {
      "source": "fn add256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    let mut res: [u8; 32] = [0; 32];\n    let mut carry: u16 = 0;\n    // byte-wise from LSB (index 0) to MSB (index 31)\n    for i in 0..32 {\n        let sum: u16 = carry + a[i] as u16 + b[i] as u16;\n        res[i] = (sum & 0xFF) as u8;\n        carry = sum >> 8; // carry is 0 or 1 (max sum = 0x1FE) :contentReference[oaicite:0]{index=0}\n    }\n    res\n}\n\nfn sub256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    let mut res: [u8; 32] = [0; 32];\n    let mut borrow: i16 = 0;\n    // same direction\n    for i in 0..32 {\n        let diff: i16 = a[i] as i16 - b[i] as i16 - borrow;\n        // if diff < 0, add 256 and borrow=1; else borrow=0 :contentReference[oaicite:1]{index=1}\n        if diff < 0 {\n            res[i] = (diff + 256) as u8;\n            borrow = 1;\n        } else {\n            res[i] = diff as u8;\n            borrow = 0;\n        }\n    }\n    res\n}\n\nfn mul256(a: [u8; 32], b: [u8; 32]) -> [u8; 32] {\n    // temporary 64-byte array for full 512-bit product\n    let mut tmp: [u32; 64] = [0; 64];\n\n    for i in 0..32 {\n        for j in 0..32 {\n            tmp[i + j] = tmp[i + j] + (a[i] as u32) * (b[j] as u32);\n        }\n    }\n\n    // propagate carries mod 2^256: only indices 0..31 are output\n    let mut res: [u8; 32] = [0; 32];\n    let mut carry: u32 = 0;\n    for k in 0..32 {\n        let sum: u32 = tmp[k] + carry;\n        res[k] = (sum & 0xFF) as u8; // lower byte\n        carry = sum >> 8; // next carry\n    }\n    res\n}\n\nuse std::cmp::{Eq, Ord, Ordering};\nuse std::ops::{Add, Mul, Sub};\n\npub struct U256Bytes {\n    pub limbs: [u8; 32],\n}\n\nimpl U256Bytes {\n    pub fn new(limbs: [u8; 32]) -> Self {\n        U256Bytes { limbs }\n    }\n\n    pub fn zero() -> Self {\n        U256Bytes { limbs: [0; 32] }\n    }\n}\n\nimpl Add for U256Bytes {\n    fn add(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: add256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Sub for U256Bytes {\n    fn sub(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: sub256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Mul for U256Bytes {\n    fn mul(self, other: U256Bytes) -> U256Bytes {\n        U256Bytes { limbs: mul256(self.limbs, other.limbs) }\n    }\n}\n\nimpl Eq for U256Bytes {\n    fn eq(self, other: U256Bytes) -> bool {\n        let mut is_eq: bool = true; // start true :contentReference[oaicite:2]{index=2}\n        for i in 0..32 {\n            // loop over each 64-bit limb :contentReference[oaicite:3]{index=3}\n            // constrained equality on u64, then AND into is_eq\n            is_eq = is_eq & (self.limbs[i] == other.limbs[i]);\n        }\n        is_eq // single return here :contentReference[oaicite:5]{index=5}\n    }\n}\n\nimpl Ord for U256Bytes {\n    fn cmp(self, other: U256Bytes) -> Ordering {\n        let mut less_flag: bool = false; // true if we've seen a < case :contentReference[oaicite:8]{index=8}\n        let mut greater_flag: bool = false; // true if we've seen a > case :contentReference[oaicite:9]{index=9}\n        let mut prefix_equal: bool = true; // true if all more-significant limbs so far were equal :contentReference[oaicite:10]{index=10}\n\n        // Walk from MS limb (3) down to LS limb (0)\n        for i in 0..32 {\n            let a = self.limbs[i];\n            let b = other.limbs[i];\n            let eq = a == b; // constrained eq :contentReference[oaicite:11]{index=11}\n            let lt = a < b; // constrained lt :contentReference[oaicite:12]{index=12}\n            let gt = a > b; // constrained gt :contentReference[oaicite:13]{index=13}\n\n            // Only update if all higher limbs were equal\n            less_flag = less_flag | (prefix_equal & lt);\n            greater_flag = greater_flag | (prefix_equal & gt);\n            prefix_equal = prefix_equal & eq;\n        }\n\n        // Single return, based on the flags\n        if greater_flag {\n            Ordering::greater()\n        } // constrained branch :contentReference[oaicite:17]{index=17}\n        else if less_flag {\n            Ordering::less()\n        } // constrained branch :contentReference[oaicite:18]{index=18}\n        else {\n            Ordering::equal()\n        } // all limbs equal :contentReference[oaicite:19]{index=19}\n    }\n}\n",
      "path": "/Users/ataberkcekic/main-code/projects/snac/snac_circuits/snac_send_token_out_circuit/src/U256.nr"
    },
    "62": {
      "source": "mod U256;\nuse U256::U256Bytes;\n\nstruct InUtxo {\n    deposit_hash: [u8; 32],\n    amount: [u8; 32],\n    signature: [u8; 64],\n    nullifier_hash: [u8; 32],\n}\n\nstruct Utxo {\n    contract_address: [u8; 20],\n    amount: [u8; 32],\n    deposit_hash: [u8; 32],\n    nullifier_hash: [u8; 32],\n}\n\nimpl Utxo {\n    fn new(\n        contract_address: [u8; 20],\n        amount: [u8; 32],\n        deposit_hash: [u8; 32],\n        nullifier_hash: [u8; 32],\n    ) -> Self {\n        Self { contract_address, amount, deposit_hash, nullifier_hash }\n    }\n\n    fn to_bytes(self) -> [u8; 116] {\n        let mut utxo_bytes: [u8; 116] = [0; 116];\n\n        for i in 0..20 {\n            utxo_bytes[i] = self.contract_address[i];\n        }\n        for i in 20..52 {\n            utxo_bytes[i] = self.amount[i - 20];\n        }\n        for i in 52..84 {\n            utxo_bytes[i] = self.deposit_hash[i - 52];\n        }\n        for i in 84..116 {\n            utxo_bytes[i] = self.nullifier_hash[i - 84];\n        }\n        utxo_bytes\n    }\n}\n\nunconstrained fn check_utxo(\n    utxo: InUtxo,\n    contract_address: [u8; 20],\n    utxo_commitment: [u8; 32],\n    ownership_commitment: [u8; 32],\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n) -> U256Bytes {\n    // check is the signature is created with that utxo deposit hash\n    assert(std::ecdsa_secp256k1::verify_signature(\n        public_key_x,\n        public_key_y,\n        utxo.signature,\n        utxo.deposit_hash,\n    ));\n\n    let calc_ownership_commitment = std::hash::keccak256(utxo.signature, 64);\n\n    assert(calc_ownership_commitment == ownership_commitment);\n\n    let utxo_bytes = Utxo::new(\n        contract_address,\n        utxo.amount,\n        utxo.deposit_hash,\n        utxo.nullifier_hash,\n    )\n        .to_bytes();\n\n    let digest = std::hash::keccak256(utxo_bytes, 116);\n\n    assert(digest == utxo_commitment);\n\n    U256Bytes::new(utxo.amount)\n}\n\npub struct ReturnValues {\n    utxo_commitment: [u8; 32],\n    utxo_bytes: [u8; 116],\n}\n\nunconstrained fn main(\n    utxos: [InUtxo; 3],\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    utxo_commitments: pub [[u8; 32]; 3],\n    ownership_commitments: pub [[u8; 32]; 3],\n    utxo_len: u8,\n    contract_address: pub [u8; 20],\n    send_amount: pub [u8; 32],\n    deposit_hash: pub [u8; 32],\n    nullifier_hash: [u8; 32],\n) -> pub ReturnValues {\n    assert(utxo_len < 4);\n    let mut amount = U256Bytes::zero();\n\n    let send_amount = U256Bytes::new(send_amount);\n\n    for i in 0..utxo_len {\n        let utxo_amount = check_utxo(\n            utxos[i],\n            contract_address,\n            utxo_commitments[i],\n            ownership_commitments[i],\n            public_key_x,\n            public_key_y,\n        );\n        amount += utxo_amount;\n    }\n\n    assert(send_amount <= amount);\n\n    let left_amount = amount - send_amount;\n\n    let utxo_bytes = Utxo::new(\n        contract_address,\n        left_amount.limbs,\n        deposit_hash,\n        nullifier_hash,\n    )\n        .to_bytes();\n\n    let utxo_commitment = std::hash::keccak256(utxo_bytes, 116);\n\n    ReturnValues { utxo_commitment: utxo_commitment, utxo_bytes: utxo_bytes }\n}\n\n#[test]\nfn test_main() {\n    //let a = main(utxos,\"0xD7B26926901469501C66e084e0bB71599599025A\",5,\"0xD7B26926901469501C66e084e0bB71599599025A\",\"0xD7B26926901469501C66e084e0bB71599599025A\",\"0xD7B26926901469501C66e084e0bB71599599025A\");\n    //assert_eq(main(3,2,1,1,1),main(4,3,3,2,1));\n\n    let mut amount = U256Bytes::zero();\n\n    let public_key_x: [u8; 32] = [\n        111, 241, 83, 107, 82, 101, 101, 129, 169, 66, 17, 44, 124, 17, 14, 45, 8, 174, 17, 107,\n        158, 25, 40, 101, 156, 220, 247, 149, 102, 64, 184, 117,\n    ];\n\n    let public_key_y: [u8; 32] = [\n        57, 45, 119, 29, 254, 73, 64, 167, 113, 188, 250, 60, 71, 96, 247, 41, 94, 48, 94, 169, 106,\n        183, 5, 186, 77, 30, 252, 151, 59, 252, 102, 165,\n    ];\n\n    let message_hash: [u8; 32] = [\n        74, 92, 93, 69, 71, 33, 187, 187, 37, 84, 12, 51, 23, 82, 30, 113, 195, 115, 174, 54, 69,\n        143, 150, 13, 42, 212, 110, 240, 136, 17, 14, 149,\n    ];\n\n    let signature: [u8; 64] = [\n        1, 51, 20, 152, 243, 70, 196, 142, 235, 229, 8, 188, 86, 121, 134, 105, 178, 60, 250, 236,\n        22, 0, 103, 118, 181, 177, 152, 213, 135, 228, 105, 46, 17, 106, 197, 154, 89, 129, 24, 102,\n        210, 159, 211, 113, 16, 121, 198, 235, 26, 101, 156, 0, 116, 174, 205, 62, 81, 166, 43, 234,\n        107, 8, 33, 72,\n    ];\n    // 4. Verify\n    let is_valid =\n        std::ecdsa_secp256k1::verify_signature(public_key_x, public_key_y, signature, message_hash);\n\n    assert(is_valid); // should pass\n}\n",
      "path": "/Users/ataberkcekic/main-code/projects/snac/snac_circuits/snac_send_token_out_circuit/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": ["main"]
}
